/*
	SFE_BMP180.cpp
	Bosch BMP180 pressure sensor library for the Arduino microcontroller
	Mike Grusin, SparkFun Electronics

	Uses floating-point equations from the Weather Station Data Logger project
	http://wmrx00.sourceforge.net/
	http://wmrx00.sourceforge.net/Arduino/BMP085-Calcs.pdf

	Forked from BMP085 library by M.Grusin

	version 1.0 2013/09/20 initial version

	Our example code uses the "beerware" license. You can do anything
	you like with this code. No really, anything. If you find it useful,
	buy me a (root) beer someday.
*/

#include <stdio.h>
#include <math.h>
#include <unistd.h>
#include "interface.h"
#include "bmp180.h"
#include "i2cdev/i2cdev.h"

#define delay_ms(a)    usleep(a*1000)

#define BMP180_ADDR 0x77 // 7-bit address

#define BMP180_REG_CONTROL 0xF4
#define BMP180_REG_RESULT 0xF6

#define BMP180_COMMAND_TEMPERATURE 0x2E
#define BMP180_COMMAND_PRESSURE0 0x34
#define BMP180_COMMAND_PRESSURE1 0x74
#define BMP180_COMMAND_PRESSURE2 0xB4
#define BMP180_COMMAND_PRESSURE3 0xF4

static struct s_cc {
	short AC1,AC2,AC3,VB1,VB2,MB,MC,MD;
	unsigned short AC4,AC5,AC6;
	double c5,c6,mc,md,x0,x1,x2,y0,y1,y2,p0,p1,p2;
} cc; //calibration coefficients

static int ret = 0;

int bs_open()
// Initialize library for subsequent pressure measurements
{
	double c3,c4,b1;
	

	// The BMP180 includes factory calibration data stored on the device.
	// Each device has different numbers, these must be retrieved and
	// used in the calculations when taking pressure measurements.

	// Retrieve calibration data from device:
	
	if (bsReadS(0xAA,cc.AC1) &&
		bsReadS(0xAC,cc.AC2) &&
		bsReadS(0xAE,cc.AC3) &&
		bsReadU(0xB0,cc.AC4) &&
		bsReadU(0xB2,cc.AC5) &&
		bsReadU(0xB4,cc.AC6) &&
		bsReadS(0xB6,cc.VB1) &&
		bsReadS(0xB8,cc.VB2) &&
		bsReadS(0xBA,cc.MB) &&
		bsReadS(0xBC,cc.MC) &&
		bsReadS(0xBE,cc.MD))
	{


/*
		cc.AC1=408;
		cc.AC2=-72;
		cc.AC3=-14383;
		cc.AC4=32741;
		cc.AC5=32757;
		cc.AC6=23153;
		cc.VB1=6190;
		cc.VB2=4;
		cc.MB=-32768;
		cc.MC=-8711;
		cc.MD=2868;
		// All reads completed successfully!
*/
		// If you need to check your math using known numbers,
		// you can uncomment one of these examples.
		// (The correct results are commented in the below functions.)

		// Example from Bosch datasheet
		// AC1 = 408; AC2 = -72; AC3 = -14383; AC4 = 32741; AC5 = 32757; AC6 = 23153;
		// B1 = 6190; B2 = 4; MB = -32768; MC = -8711; MD = 2868;

		// Example from http://wmrx00.sourceforge.net/Arduino/BMP180-Calcs.pdf
		// AC1 = 7911; AC2 = -934; AC3 = -14306; AC4 = 31567; AC5 = 25671; AC6 = 18974;
		// VB1 = 5498; VB2 = 46; MB = -32768; MC = -11075; MD = 2432;

#ifdef BMP_DEBUG
		printf("AC1: %i\n",cc.AC1);
		printf("AC2: %i\n",cc.AC2);
		printf("AC3: %i\n",cc.AC3);
		printf("AC4: %u\n",cc.AC4);
		printf("AC5: %u\n",cc.AC5);
		printf("AC6: %u\n",cc.AC6);
		printf("VB1: %i\n",cc.VB1);
		printf("VB2: %i\n",cc.VB2);
		printf("MB: %i\n",cc.MB);
		printf("MC: %i\n",cc.MC);
		printf("MD: %i\n",cc.MD); 
#endif
		
		// Compute floating-point polynominals:

		c3 = 160.0 * pow(2,-15) * cc.AC3;
		c4 = pow(10,-3) * pow(2,-15) * cc.AC4;
		b1 = pow(160,2) * pow(2,-30) * cc.VB1;
		cc.c5 = (pow(2,-15) / 160) * cc.AC5;
		cc.c6 = cc.AC6;
		cc.mc = (pow(2,11) / pow(160,2)) * cc.MC;
		cc.md = cc.MD / 160.0;
		cc.x0 = cc.AC1;
		cc.x1 = 160.0 * pow(2,-13) * cc.AC2;
		cc.x2 = pow(160,2) * pow(2,-25) * cc.VB2;
		cc.y0 = c4 * pow(2,15);
		cc.y1 = c4 * c3;
		cc.y2 = c4 * b1;
		cc.p0 = (3791.0 - 8.0) / 1600.0;
		cc.p1 = 1.0 - 7357.0 * pow(2,-20);
		cc.p2 = 3038.0 * 100.0 * pow(2,-36);

#ifdef BMP_DEBUG
		printf("\nc3: %5.3f\n",c3);
		printf("c5: %5.3f\n",cc.c6);
		printf("b1: %5.3f\n",b1);
		printf("mc: %5.3f\n",cc.mc);
		printf("md: %5.3f\n",cc.md);
		printf("x0: %5.3f\n",cc.x0);
		printf("x1: %5.3f\n",cc.x1);
		printf("x2: %5.3f\n",cc.x2);
		printf("y0: %5.3f\n",cc.y0);
		printf("y1: %5.3f\n",cc.y1);
		printf("y2: %5.3f\n",cc.y2);
		printf("p0: %5.3f\n",cc.p0);
		printf("p1: %5.3f\n",cc.p1);
		printf("p2: %5.3f\n",cc.p2);
#endif
		
		// Success!
		ret = prepareTemperature();
		if (ret<0) {
			printf("BMP: Failed to request temperature (%i)!\n",ret);
			return ret;
		}
		ret = preparePressure(1);
		if (ret<0) {
			printf("BMP: Failed to request pressure (%i)!\n",ret);
			return ret;
		}
		delay_ms(30);
		ret=bs_update();
		if (ret<0) {
			printf("BMP: Failed to get an update (%i)!\n",ret);
			return ret;
		}
		bs.p0 = bs.p;
		delay_ms(30);

		return(0);
	}
	else
	{
		printf("BMP: Failed to read calibration valued!\n");
		// Error reading calibration data; bad component or connection?
		return(-1);
	}
}

int bs_update() {
	pthread_mutex_lock( &bs.mutex );
        clock_gettime(CLOCK_REALTIME, &bs.ts);
	ret = getTemperature(bs.t);
	if (ret<0) {
		pthread_mutex_unlock( &bs.mutex );
		printf("Error temp!\n");
		return 100+ret;
	}
	ret = getPressure(bs.p, bs.t);
	if (ret<0) {
		pthread_mutex_unlock( &bs.mutex );
		printf("Error press!\n");
		return 200+ret;
	}
	bs.alt = altitude(bs.p, bs.p0); 

	prepareTemperature();
	preparePressure(1); //need to wait at least 20ms?? see datasheet
	pthread_mutex_unlock( &bs.mutex );
	return 0;
}


static int prepareTemperature(void)
// Begin a temperature reading.
{
	unsigned char data[2], result;
	
	data[0] = BMP180_REG_CONTROL;
	data[1] = BMP180_COMMAND_TEMPERATURE;
	ret = bsWriteBytes(data, 2);
	return ret;
}

static int getTemperature(double &T)
// Retrieve a previously-started temperature reading.
// Requires begin() to be called once prior to retrieve calibration parameters.
// Requires startTemperature() to have been called prior and sufficient time elapsed.
// T: external variable to hold result.
{
	unsigned char data[2];
	long tu;
//	double a;
	
	data[0] = BMP180_REG_RESULT;

	ret = bsReadBytes(data, 2);
	if (ret>0) // good read, calculate temperature
	{
		tu = (((long)data[0]) << 8) + ((long)data[1]);
//tu=27898;
//		a = cc.c5 * (tu - cc.c6);
//		T = a + (cc.mc / (a + cc.md));

long X1 = ((tu - cc.AC6) * cc.AC5) >> 15;
long X2 = (cc.MC << 11) / (double)(X1 + cc.MD);
long B5 = X1 + X2;
long temp = (B5 + 8) >> 4;
T = temp/10.0f;
		//return ret;

		//tu = (data[0] * 256.0) + data[1];

		//example from Bosch datasheet
		//tu = 27898;

		//example from http://wmrx00.sourceforge.net/Arduino/BMP085-Calcs.pdf
		//tu = 0x69EC;
		

#ifdef BMP_DEBUG
		printf("tu: %5.3f\ta: %5.3f\tT:%5.3f\n",tu,a,T);
#endif
	}
	return ret;
}

static int preparePressure(int oversampling)
// Begin a pressure reading.
// Oversampling: 0 to 3, higher numbers are slower, higher-res outputs.
// Will return delay in ms to wait, or 0 if I2C error.
{
	unsigned char data[2];
	
	data[0] = BMP180_REG_CONTROL;

	switch (oversampling)
	{
		case 0:
			data[1] = BMP180_COMMAND_PRESSURE0;
		break;
		case 1:
			data[1] = BMP180_COMMAND_PRESSURE1;
		break;
		case 2:
			data[1] = BMP180_COMMAND_PRESSURE2;
		break;
		case 3:
			data[1] = BMP180_COMMAND_PRESSURE3;
		break;
		default:
			data[1] = BMP180_COMMAND_PRESSURE0;
		break;
	}
	ret=bsWriteBytes(data,2);  // good write?
	return ret;
}


static int getPressure(double &P, double &T)
// Retrieve a previously started pressure reading, calculate abolute pressure in mbars.
// Requires begin() to be called once prior to retrieve calibration parameters.
// Requires startPressure() to have been called prior and sufficient time elapsed.
// Requires recent temperature reading to accurately calculate pressure.

// P: external variable to hold pressure.
// T: previously-calculated temperature.

// Note that calculated pressure value is absolute mbars, to compensate for altitude call sealevel().
{
	unsigned char data[3];
	double pu,s,x,y,z;
	
	data[0] = BMP180_REG_RESULT;

	if (ret = bsReadBytes(data,3)) // good read, calculate pressure
	{
		pu = (data[0] * 256.0f) + data[1] + (data[2]/256.0f);
//		pu = 23848;

		//example from Bosch datasheet
		//pu = 23843;

		//example from http://wmrx00.sourceforge.net/Arduino/BMP085-Calcs.pdf, pu = 0x982FC0;	
		//pu = (0x98 * 256.0) + 0x2F + (0xC0/256.0);
		
		s = T - 25.0;
		x = (cc.x2 * pow(s,2)) + (cc.x1 * s) + cc.x0;
		y = (cc.y2 * pow(s,2)) + (cc.y1 * s) + cc.y0;
		z = (pu - x) / y;
		P = (cc.p2 * pow(z,2)) + (cc.p1 * z) + cc.p0;

#ifdef BMP_DEBUG
		printf("pu: %5.3f\n",pu); 
		printf("T: %5.3f\n",T);
		printf("s: %5.3f\n",s);
		printf("x: %5.3f\n",x);
		printf("y: %5.3f\n",y);
		printf("z: %5.3f\n",z);
		printf("P: %5.3f\n",P);
#endif
		return 0;
	}
	return ret;
}


static double altitude(double P, double P0)
// Given a pressure measurement P (mb) and the pressure at a baseline P0 (mb),
// return altitude (meters) above baseline.
{
	return(44330.0*(1-pow(P/P0,1/5.255)));
}


static int bsReadS(unsigned char address, short &value)
// Read a signed integer (two bytes) from device
// address: register to start reading (plus subsequent register)
// value: external variable to store data (function modifies value)
{
	unsigned short data[2];

	data[0] = address;
	//printf("%#x %#x\n",data[0],data[1]);
	ret=bsReadBytes((unsigned char*)data,2);
	//printf("%#x %#x\n\n\n\n\n\n",data[0],data[1]);
	if (ret>0)
	{
		value = (((short)data[0])<<8)|((short)data[1]);
		//value = (int)((((int)data[0])<<8)|((int)data[1]));
		//if (value & 0x8000) value |= 0xFFFF0000; // sign extend if negative
		return(ret);
	}
	value = 0;
	return(ret);
}


static int bsReadU(unsigned char address, unsigned short &value)
// Read an unsigned integer (two bytes) from device
// address: register to start reading (plus subsequent register)
// value: external variable to store data (function modifies value)
{
	unsigned short data[2];

	data[0] = address;
	ret=bsReadBytes((unsigned char*)data,2);
	if (ret>0)
	{
		value = (data[0]<<8)|data[1];
		return(ret);
	}
	value = 0;
	return(ret);
}


static int bsReadBytes(unsigned char *values, char length)
// Read an array of bytes from device
// values: external array to hold data. Put starting register in values[0].
// length: number of bytes to read
{
	return readBytes(BMP180_ADDR,values[0],length,values); //return number of bytes read
}


static int bsWriteBytes(unsigned char *values, char length)
// Write an array of bytes to device
// values: external array of data to write. Put starting register in values[0].
// length: number of bytes to write
{
	ret=writeBytes(BMP180_ADDR,values[0],length-1,values+1);
	return ret;
}



